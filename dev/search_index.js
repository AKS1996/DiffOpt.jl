var documenterSearchIndex = {"docs":
[{"location":"solve-QP/#solving-QP-primal","page":"Solving a QP","title":"solving QP primal","text":"","category":"section"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"using Random\nusing MathOptInterface\nusing Dualization\nusing OSQP\n\nconst MOI = MathOptInterface\nconst MOIU = MathOptInterface.Utilities;","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"n = 20 # variable dimension\nm = 15 # no of inequality constraints\np = 15; # no of equality constraints","category":"page"},{"location":"solve-QP/#create-a-non-trivial-QP-problem","page":"Solving a QP","title":"create a non-trivial QP problem","text":"","category":"section"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"textmin  frac12x^TQx + q^Tx","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"textst  Gx = h","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"Ax = b ","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"x̂ = rand(n)\nQ = rand(n, n)\nQ = Q'*Q # ensure PSD\nq = rand(n)\nG = rand(m, n)\nh = G*x̂ + rand(m)\nA = rand(p, n)\nb = A*x̂;","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"model = MOI.instantiate(OSQP.Optimizer, with_bridge_type=Float64)\nx = MOI.add_variables(model, n);","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"# define objective\n\nquad_terms = MOI.ScalarQuadraticTerm{Float64}[]\nfor i in 1:n\n    for j in i:n # indexes (i,j), (j,i) will be mirrored. specify only one kind\n        push!(quad_terms, MOI.ScalarQuadraticTerm(Q[i,j],x[i],x[j]))\n    end\nend\n\nobjective_function = MOI.ScalarQuadraticFunction(MOI.ScalarAffineTerm.(q, x),quad_terms,0.0)\nMOI.set(model, MOI.ObjectiveFunction{MOI.ScalarQuadraticFunction{Float64}}(), objective_function)\nMOI.set(model, MOI.ObjectiveSense(), MOI.MIN_SENSE)","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"# maintain constrain to index map - will be useful later\nconstraint_map = Dict()\n\n# add constraints\nfor i in 1:m\n    ci = MOI.add_constraint(model,MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(G[i,:], x), 0.),MOI.LessThan(h[i]))\n    constraint_map[ci] = i\nend\n\nfor i in 1:p\n    ci = MOI.add_constraint(model,MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(A[i,:], x), 0.),MOI.EqualTo(b[i]))\n    constraint_map[ci] = i\nend","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"MOI.optimize!(model)","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"@assert MOI.get(model, MOI.TerminationStatus()) in [MOI.LOCALLY_SOLVED, MOI.OPTIMAL]","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"x̄ = MOI.get(model, MOI.VariablePrimal(), x);","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"# objective value (predicted vs actual) sanity check\n@assert 0.5*x̄'*Q*x̄ + q'*x̄  <= 0.5*x̂'*Q*x̂ + q'*x̂   ","category":"page"},{"location":"solve-QP/#find-and-solve-dual-problem","page":"Solving a QP","title":"find and solve dual problem","text":"","category":"section"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"primal dual\ntextmin  frac12x^TQx + q^Tx textmax  -frac12y^TQ^-1y - u^Th - v^Tb\ntextst  Gx = h textst   u geq 0 u in R^m v in R^n\nAx = b y = q + G^Tu + A^Tv","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"Each primal variable becomes a dual constraint\nEach primal constraint becomes a dual variable","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"# NOTE: can't use Ipopt\n# Ipopt.Optimizer doesn't supports accessing MOI.ObjectiveFunctionType\n\njoint_object    = dualize(model)\ndual_model_like = joint_object.dual_model # this is MOI.ModelLike, not an MOI.AbstractOptimizer; can't call optimizer on it\nprimal_dual_map = joint_object.primal_dual_map;","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"# copy the dual model objective, constraints, and variables to an optimizer\ndual_model = MOI.instantiate(OSQP.Optimizer, with_bridge_type=Float64)\nMOI.copy_to(dual_model, dual_model_like)\n\n# solve dual\nMOI.optimize!(dual_model);","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"# check if strong duality holds\n@assert abs(MOI.get(model, MOI.ObjectiveValue()) - MOI.get(dual_model, MOI.ObjectiveValue())) <= 1e-1","category":"page"},{"location":"solve-QP/#derive-and-verify-KKT-conditions","page":"Solving a QP","title":"derive and verify KKT conditions","text":"","category":"section"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"is_equality(set::S) where {S<:MOI.AbstractSet} = false\nis_equality(set::MOI.EqualTo{T}) where T = true\n\nmap = primal_dual_map.primal_con_dual_var;","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"complimentary slackness: mu_i(Gbar x -h)_i=0 qquad text where  i=1m","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"for con_index in keys(map)\n    # NOTE: OSQP.Optimizer doesn't allows access to MOI.ConstraintPrimal\n    #       That's why I defined a custom map \n    \n    set = MOI.get(model, MOI.ConstraintSet(), con_index)\n    μ   = MOI.get(dual_model, MOI.VariablePrimal(), map[con_index][1])\n    \n    if !is_equality(set)\n        # μ[i]*(Gx - h)[i] = 0\n        i = constraint_map[con_index]\n        \n        # println(μ,\" - \",G[i,:]'*x̄, \" - \",h[i])\n        # TODO: assertion fails \n        @assert μ*(G[i,:]'*x̄ - h[i]) < 1e-1  \n    end\nend","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"primal feasibility:  (Gbar x -h)_i=0 qquad text where  i=1m (Abar x -b)_j=0 qquad text where  j=1p","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"dual feasibility:  mu_i geq 0 qquad text where  i=1m","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"for con_index in keys(map)\n    # NOTE: OSQP.Optimizer doesn't allows access to MOI.ConstraintPrimal\n    #       That's why I defined a custom map \n    \n    set = MOI.get(model, MOI.ConstraintSet(), con_index)\n    μ   = MOI.get(dual_model, MOI.VariablePrimal(), map[con_index][1])\n    i = constraint_map[con_index]\n    \n    if is_equality(set)\n        # (Ax - h)[i] = 0\n        @assert abs(A[i,:]'*x̄ - b[i]) < 1e-2\n    else\n        # (Gx - h)[i] = 0\n        @assert G[i,:]'*x̄ - h[i] < 1e-2\n        \n        # μ[i] >= 0\n        # TODO: assertion fails \n        @assert μ > -1e-2\n    end\nend","category":"page"},{"location":"solve-QP/","page":"Solving a QP","title":"Solving a QP","text":"","category":"page"},{"location":"solve-LP/#solving-LP-primal","page":"Solving an LP","title":"solving LP primal","text":"","category":"section"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"using Random\nusing GLPK\nusing MathOptInterface\nusing Dualization\n\nconst MOI  = MathOptInterface\nconst MOIU = MathOptInterface.Utilities;","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"D = 10  # variable dimension\nN = 20; # no of inequality constraints","category":"page"},{"location":"solve-LP/#create-a-non-trivial-LP-problem","page":"Solving an LP","title":"create a non-trivial LP problem","text":"","category":"section"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"textmin  c^Tx","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"textst  Ax leq b","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"$$x \\geq 0, x \\in R^D$$","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"s = rand(N)\ns = 2*s.-1\nλ = max.(-s, 0)\ns = max.(s, 0)\nx̂ = rand(D)\nA = rand(N, D)\nb = A*x̂ .+ s\nc = -A'*λ;","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"# can feed dual problem to optimizer like this:\n# model = MOI.instantiate(dual_optimizer(GLPK.Optimizer), with_bridge_type=Float64)\n\nmodel = GLPK.Optimizer()\nx = MOI.add_variables(model, D)\n\n# define objective\nobjective_function = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(c, x), 0.0)\nMOI.set(model, MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(), objective_function)\nMOI.set(model, MOI.ObjectiveSense(), MOI.MIN_SENSE)","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"# will be useful later\nconstraint_indices = []\n\n# set constraints\nfor i in 1:N\n    push!(constraint_indices, MOI.add_constraint(model,MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(A[i,:], x), 0.),MOI.LessThan(b[i])))\nend\n\nfor i in 1:D\n    push!(constraint_indices, MOI.add_constraint(model,MOI.SingleVariable(x[i]),MOI.GreaterThan(0.)))\nend","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"MOI.optimize!(model)","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"@assert MOI.get(model, MOI.TerminationStatus()) in [MOI.LOCALLY_SOLVED, MOI.OPTIMAL]","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"x̄ = MOI.get(model, MOI.VariablePrimal(), x);  # solution","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"@assert abs(c'x̄ - c'x̂) <= 1e-8   # sanity check","category":"page"},{"location":"solve-LP/#find-and-solve-dual-problem","page":"Solving an LP","title":"find and solve dual problem","text":"","category":"section"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"primal dual\ntextmin  c^Tx textmax  b^Ty\ntextst  Ax leq b textst  A^Ty geq c\nx geq 0 y leq 0","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"Each primal variable becomes a dual constraint\nEach primal constraint becomes a dual variable","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"joint_object    = dualize(model)\ndual_model_like = joint_object.dual_model # this is MOI.ModelLike, not an MOI.AbstractOptimizer; can't call optimizer on it\nprimal_dual_map = joint_object.primal_dual_map;","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"# copy the dual model objective, constraints, and variables to an optimizer\ndual_model = GLPK.Optimizer()\nMOI.copy_to(dual_model, dual_model_like)\n\n# solve dual\nMOI.optimize!(dual_model);","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"# NOTE: You can obtain components of the dual model individually by -\n# dual_objective = dual_model_like.objective  # b'y\n# dual_variable_indices = [primal_dual_map.primal_con_dual_var[x][1] for x in constraint_indices]\n# dual_constraint_indices = [primal_dual_map.primal_var_dual_con[i] for i in x];\n\n# ŷ = MOI.get(dm, MOI.VariablePrimal(), dual_variable_indices)","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"# check if strong duality holds\n@assert abs(MOI.get(model, MOI.ObjectiveValue()) - MOI.get(dual_model, MOI.ObjectiveValue())) <= 1e-8","category":"page"},{"location":"solve-LP/#derive-and-verify-KKT-conditions","page":"Solving an LP","title":"derive and verify KKT conditions","text":"","category":"section"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"complimentary slackness: mu_i(Abar x -b)_i=0quad mu_j+N bar x_j =0 qquad text where  i=1N j = 1D","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"is_less_than(set::S) where {S<:MOI.AbstractSet} = false\nis_less_than(set::MOI.LessThan{T}) where T = true\n\nmap = primal_dual_map.primal_con_dual_var\nfor con_index in keys(map)\n    con_value = MOI.get(model, MOI.ConstraintPrimal(), con_index)\n    set = MOI.get(model, MOI.ConstraintSet(), con_index)\n    μ         = MOI.get(dual_model, MOI.VariablePrimal(), map[con_index][1])\n    \n    if is_less_than(set)\n        # μ[i]*(Ax - b)[i] = 0\n        @assert μ*(con_value - set.upper) < 1e-10\n    else\n        # μ[j]*x[j] = 0\n        @assert μ*(con_value - set.lower) < 1e-10\n    end\nend","category":"page"},{"location":"solve-LP/","page":"Solving an LP","title":"Solving an LP","text":"","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [DiffOpt]","category":"page"},{"location":"reference/#DiffOpt.Dπ-Tuple{Array{#s26,N} where N where #s26<:MathOptInterface.AbstractSet,Any}","page":"Reference","title":"DiffOpt.Dπ","text":"derivative of projection of vector `z` on a product of cones\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.Dπ-Tuple{MathOptInterface.Nonnegatives,Array{Float64,N} where N}","page":"Reference","title":"DiffOpt.Dπ","text":"derivative of projection of vector `z` on Nonnegative cone i.e. K = R+\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.Dπ-Tuple{MathOptInterface.PositiveSemidefiniteConeTriangle,Array{Float64,N} where N}","page":"Reference","title":"DiffOpt.Dπ","text":"derivative of projection of vector `z` on positive semidefinite cone i.e. K = S^n⨥\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.Dπ-Tuple{MathOptInterface.SecondOrderCone,Array{Float64,N} where N}","page":"Reference","title":"DiffOpt.Dπ","text":"derivative of projection of vector `z` on second order cone i.e. K = {(t, x) ∈ R+ × Rn |  ||x|| ≤ t }\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.Dπ-Tuple{MathOptInterface.Zeros,Array{Float64,N} where N}","page":"Reference","title":"DiffOpt.Dπ","text":"derivative of projection of vector `z` on zero cone i.e. K = {0}\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.backward!-Tuple{Optimizer,Array{String,N} where N,Array{Float64,N} where N}","page":"Reference","title":"DiffOpt.backward!","text":"Method to differentiate optimal solution `z` and return\nproduct of jacobian matrices (`dz / dQ`, `dz / dq`, etc) with \nthe backward pass vector `dl / dz`\n\nThe method computes the product of \n1. jacobian of problem solution `z*` with respect to \n    problem parameters `params` recieved as method arguments\n2. a backward pass vector `dl / dz`, where `l` can be a loss function\n\nNote that does not returns the actual jacobians\n\nFor more info refer eqn(7) and eqn(8) of https://arxiv.org/pdf/1703.00443.pdf\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.backward_conic!-Tuple{Optimizer,Array{Float64,2},Array{Float64,N} where N,Array{Float64,N} where N}","page":"Reference","title":"DiffOpt.backward_conic!","text":"Method to differentiate optimal solution `x`, `y`, `s`\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.create_LHS_matrix","page":"Reference","title":"DiffOpt.create_LHS_matrix","text":"Inverse matrix specified on RHS of eqn(7) in https://arxiv.org/pdf/1703.00443.pdf\n\n\n\n\n\n","category":"function"},{"location":"reference/#DiffOpt.create_RHS_matrix","page":"Reference","title":"DiffOpt.create_RHS_matrix","text":"Right hand side of eqn(6) in https://arxiv.org/pdf/1703.00443.pdf\n\n\n\n\n\n","category":"function"},{"location":"reference/#DiffOpt.generate_lp-Tuple{Any,Any,Any}","page":"Reference","title":"DiffOpt.generate_lp","text":"Generates a non-trivial random MOI linear program by adding variables and constraints to MOI compatible Optimizer optimizer\n\nminimize c' * x subject to Ax <= b, x >= 0 where x in R^{n}, A in R^{m*n}, b in R^{m}, c in R^{n}\n\nNote: Mutates the optimizer object\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.generate_qp-NTuple{4,Any}","page":"Reference","title":"DiffOpt.generate_qp","text":"Generates a non-trivial random MOI convex quadratic program  by adding variables and constraints to MOI compatible Optimizer optimizer\n\nminimize 0.5 * x' * Q * x  + q' * x subject to Gx <= h, Ax == b where x in R^{n}, Q in R^{n*n}, q in R^{n}, G in R^{m,n}, h in R^{m}, A in R^{p*n}, b in R^{p}\n\nNote: (1) Mutates the optimizer object       (2) Matrix Q is Positive Semidefinite\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.get_problem_data-Tuple{MathOptInterface.AbstractOptimizer}","page":"Reference","title":"DiffOpt.get_problem_data","text":"Return problem parameters as matrices along with other problem info\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.unvec_symm-Tuple{Any,Any}","page":"Reference","title":"DiffOpt.unvec_symm","text":"Returns a dim-by-dim symmetric matrix corresponding to `x`.\n\n`x` is a vector of length dim*(dim + 1)/2, corresponding to a symmetric\nmatrix; the correspondence is as in SCS.\nX = [ X11 X12 ... X1k\n      X21 X22 ... X2k\n      ...\n      Xk1 Xk2 ... Xkk ],\nwhere\nvec(X) = (X11, sqrt(2)*X21, ..., sqrt(2)*Xk1, X22, sqrt(2)*X32, ..., Xkk)\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.vec_symm-Tuple{Any}","page":"Reference","title":"DiffOpt.vec_symm","text":"Returns a vectorized representation of a symmetric matrix `X`.\nVectorization (including scaling) as per SCS.\nvec(X) = (X11, sqrt(2)*X21, ..., sqrt(2)*Xk1, X22, sqrt(2)*X32, ..., Xkk)\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.π","page":"Reference","title":"DiffOpt.π","text":"projection of vector `z` on zero cone i.e. K = {0} or its dual\n\n\n\n\n\n","category":"function"},{"location":"reference/#DiffOpt.π-Tuple{Array{#s15,N} where N where #s15<:MathOptInterface.AbstractSet,Any}","page":"Reference","title":"DiffOpt.π","text":"Projection onto R^n x K^* x R_+\n`cones` represents a convex cone K, and K^* is its dual cone\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.π-Tuple{MathOptInterface.Nonnegatives,Array{Float64,N} where N}","page":"Reference","title":"DiffOpt.π","text":"projection of vector `z` on Nonnegative cone i.e. K = R+\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.π-Tuple{MathOptInterface.PositiveSemidefiniteConeTriangle,Array{Float64,N} where N}","page":"Reference","title":"DiffOpt.π","text":"projection of vector `z` on positive semidefinite cone i.e. K = S^n⨥\n\n\n\n\n\n","category":"method"},{"location":"reference/#DiffOpt.π-Tuple{MathOptInterface.SecondOrderCone,Array{Float64,N} where N}","page":"Reference","title":"DiffOpt.π","text":"projection of vector `z` on second order cone i.e. K = {(t, x) ∈ R+ × Rn |  ||x|| ≤ t }\n\n\n\n\n\n","category":"method"},{"location":"#DiffOpt.jl","page":"Home","title":"DiffOpt.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DiffOpt is a package for differentiating convex optimization program (JuMP.jl or MathOptInterface.jl models) with respect to program parameters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nCurrently supports linear programs, convex quadratic programs and convex conic programs (SDP, SOCP constraints only). ","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"reference.md\",\n    \"solve-LP.md\",\n    \"solve-QP.md\",\n]\nDepth = 1","category":"page"},{"location":"#Why-are-Differentiable-optimization-problems-important?","page":"Home","title":"Why are Differentiable optimization problems important?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Differentiable optimization is a promising field of convex optimization and has many potential applications in game theory, control theory and machine learning (specifically deep learning - refer this video for more). Recent work has shown how to differentiate specific subclasses of convex optimization problems. But several applications remain unexplored (refer section 8 of this really good thesis). With the help of automatic differentiation, differentiable optimization can a significant impact on creating end-to-end systems for modelling a neural network, stochastic process, or a game.","category":"page"}]
}
